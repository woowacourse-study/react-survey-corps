# 2주차 스터디 기록

- 일시 : 2025.05.01
- 참여 인원 : 퐁쥬, 머핀, 헤일리, 캉골, 상추, 메타, 해삐
- 주제 : **상호작용성 더하기**

## 목차

- [2주차 스터디 기록](#2주차-스터디-기록)
  - [목차](#목차)
  - [1️⃣ 이벤트에 응답하기](#1️⃣-이벤트에-응답하기)
    - [✅ 이벤트 핸들러를 작성하는 여러가지 방법](#-이벤트-핸들러를-작성하는-여러가지-방법)
    - [✅ 이벤트 처리 로직을 부모 컴포넌트에서 전달하는 방법](#-이벤트-처리-로직을-부모-컴포넌트에서-전달하는-방법)
    - [✅ 이벤트가 전파되는 방식와 이를 멈추는 방법](#-이벤트가-전파되는-방식와-이를-멈추는-방법)
  - [2️⃣ State: 컴포넌트의 기억 저장소](#2️⃣-state-컴포넌트의-기억-저장소)
    - [✅ useState 훅으로 state 변수를 추가하는 방법](#-usestate-훅으로-state-변수를-추가하는-방법)
    - [✅ useState 훅이 반환하는 한 쌍의 값](#-usestate훅이-반환하는-한-쌍의-값)
    - [✅ 둘 이상의 state 변수를 추가하는 방법](#-둘-이상의-state-변수를-추가하는-방법)
    - [✅ state를 지역적이라고 하는 이유](#-state를-지역적이라고-하는-이유)
  - [3️⃣ 렌더링 그리고 커밋](#3️⃣-렌더링-그리고-커밋)
    - [✅ React에서 렌더링의 의미](#-react에서-렌더링의-의미)
    - [✅ React가 컴포넌트를 언제, 왜 렌더링 하는지](#-react가-컴포넌트를-언제-왜-렌더링-하는지)
    - [✅ 화면에 컴포넌트를 표시하는 단계](#-화면에-컴포넌트를-표시하는-단계)
    - [✅ 렌더링이 항상 DOM 업데이트를 하지 않는 이유](#-렌더링이-항상-dom-업데이트를-하지-않는-이유)
  - [\[4️⃣ 스냅샷으로서의 State\] (https://ko.react.dev/learn/state-as-a-snapshot)](#4️⃣-스냅샷으로서의-state-httpskoreactdevlearnstate-as-a-snapshot)
    - [✅ state 설정으로 리렌더링이 동작하는 방식](#-state-설정으로-리렌더링이-동작하는-방식)
    - [✅ state 업데이트 시기 및 방법](#-state-업데이트-시기-및-방법)
    - [✅ state를 설정한 직후에 state가 업데이트되지 않는 이유](#-state를-설정한-직후에-state가-업데이트되지-않는-이유)
    - [✅ 이벤트 핸들러가 state의 “스냅샷”에 접근하는 방법](#-이벤트-핸들러가-state의-스냅샷에-접근하는-방법)
  - [\[5️⃣ State 업데이트 큐\] (https://ko.react.dev/learn/queueing-a-series-of-state-updates)](#5️⃣-state-업데이트-큐-httpskoreactdevlearnqueueing-a-series-of-state-updates)
    - [✅ ”batching”이란 무엇이며 React가 여러 state 업데이트를 처리하는 방법](#-batching이란-무엇이며-react가-여러-state-업데이트를-처리하는-방법)
    - [✅ 동일한 state 변수에서 여러 업데이트를 연속으로 적용하는 방법](#-동일한-state-변수에서-여러-업데이트를-연속으로-적용하는-방법)
  - [\[6️⃣ 객체 State 업데이트하기\] (https://ko.react.dev/learn/updating-objects-in-state)](#6️⃣-객체-state-업데이트하기-httpskoreactdevlearnupdating-objects-in-state)
    - [✅ React state에서 객체를 올바르게 업데이트하는 방법](#-react-state에서-객체를-올바르게-업데이트하는-방법)
    - [✅ 중첩된 객체를 변경하지 않고 업데이트하는 방법](#-중첩된-객체를-변경하지-않고-업데이트하는-방법)
    - [✅ 불변성이란 무엇인지, 그리고 불변성을 지키는 방법](#-불변성이란-무엇인지-그리고-불변성을-지키는-방법)
    - [✅ Immer로 반복을 줄여 객체를 복사하는 방법](#-immer로-반복을-줄여-객체를-복사하는-방법)
  - [\[7️⃣ 배열 State 업데이트하기\] (https://ko.react.dev/learn/updating-arrays-in-state)](#7️⃣-배열-state-업데이트하기-httpskoreactdevlearnupdating-arrays-in-state)
  - [회고](#회고)

---

## [1️⃣ 이벤트에 응답하기](https://ko.react.dev/learn/responding-to-events)

> **학습 내용**
>
> - [이벤트 핸들러를 작성하는 여러가지 방법](#-이벤트-핸들러를-작성하는-여러가지-방법)
> - [이벤트 처리 로직을 부모 컴포넌트에서 전달하는 방법](#-이벤트-처리-로직을-부모-컴포넌트에서-전달하는-방법)
> - [이벤트가 전파되는 방식와 이를 멈추는 방법](#-이벤트가-전파되는-방식와-이를-멈추는-방법)

<br/>

### ✅ 이벤트 핸들러를 작성하는 여러가지 방법

인라인으로 정의하거나, 함수로 전달하기.

단, 함수로 전달할때는 함수 호출식으로 전달해선 안된다.

```jsx

// 인라인으로 정의하는 방법
<button onClick={function handleClick() {
  alert('You clicked me!');
}}>

// 함수로 선언하고 전달하기
<button onClick={handleClick}>

// 함수 전달의 잘못된 방법 (함수 호출방식)
<button onClick={handleClick()}>
```

<br/>

### ✅ 이벤트 처리 로직을 부모 컴포넌트에서 전달하는 방법

컴포넌트가 그 부모 컴포넌트로부터 받은 props를 이벤트 핸들러로 전달하기

```jsx
function Button({ onClick, children }) {
  // 부모 컴포넌트가 자식 컴포넌트에게 onClick props 전달
  return <button onClick={onClick}>{children}</button>;
}
```

<br/>

### ✅ 이벤트가 전파되는 방식와 이를 멈추는 방법

![이벤트 전파](/study-docs/assets/3주차/eventPropagation.png)

> html 문서의 각 element들은 계층적으로 구성되어있다.
>
> 이러한 게층적 구조 특징 때문에 html 요소에서 이벤트가 발생할 경우 **연쇄적 이벤트 흐름**이 일어나게 된다.
>
> 이러한 현상을 **이벤트 전파**라고 부르며, 전파 방향에 따라 버블링과 캡쳐링으로 구분한다.
>
> **버블링** : 자식에서 발생한 event -> 부모 전파
>
> **캡쳐링** : 자식에서 발생한 event -> 부모 요소부터 시작하여 안쪽 자식요소까지 도달
>
> - 출처 : [한눈에 이해하는 이벤트 흐름 제어 (버블링 & 캡처링)](https://inpa.tistory.com/entry/JS-📚-버블링-캡쳐링)

버블링 / 캡쳐링이 일어나는 이유는 이벤트를 처리할 요소를 찾지 못했기 때문이다. (캡쳐링 event 또는 스크롤 이벤트 제외)

`e.stopPropagation()`은 핸들러가 상위 태그에서 실행되지 않도록 멈추는 것을 의미한다. (부모로 이벤트 전파 방지)

<br/>

---

<br/>

## [2️⃣ State: 컴포넌트의 기억 저장소](https://ko.react.dev/learn/state-a-components-memory)

> **학습 내용**
>
> - [useState 훅으로 state 변수를 추가하는 방법](#-usestate-훅으로-state-변수를-추가하는-방법)
> - [useState 훅이 반환하는 한 쌍의 값](#-usestate훅이-반환하는-한-쌍의-값)
> - [둘 이상의 state 변수를 추가하는 방법](#-둘-이상의-state-변수를-추가하는-방법)
> - [state를 지역적이라고 하는 이유](#-state를-지역적이라고-하는-이유)

<br/>

### ✅ useState 훅으로 state 변수를 추가하는 방법

`[value, setValue] = useState()` 식을 통해서 state 추가

**훅은 React가 오직 렌더링 중일때만 사용할 수 있는 특별한 함수**이다. (3주차에서 추가 설명)

훅은 조건문 / 반목문에서 사용할 수 없다. 오직 **최상위 컴포넌트**에서만 사용할 수 있다.

- 훅은 배열로 관리되며, **호출 순서**로 추적하기 때문에 조건문 안에서 관리할 수 없다.
- 순서가 꼬이면 그 이후 훅 부터는 상태와 참조가 꼬이게 된다. 그래서 조건문에서는 사용할 수 없다. => (그래서 훅에는 식별자가 없다)

<br/>

### ✅ useState 훅이 반환하는 한 쌍의 값

```jsx
[value, setValue] = useSate();
```

<br/>

### ✅ 둘 이상의 state 변수를 추가하는 방법

최상위 컴포넌트에서 state를 2개 만들면 된다.

<br/>

### ✅ state를 지역적이라고 하는 이유

컴포넌트마다 state 공유가 되지 않기 때문이다.

<br/>

**📎 토론 내용**

- 머핀 : 컴포넌트가 함수라는 개념이 연결이 잘 안됐었다. Javascript 함수니까 일반 함수처럼 동작하는게 맞는데 개념적인 연결이 잘 안됐었는데 공식문서에서 계속 **컴포넌트는 함수다**라고 얘기해줘서 좋았다.

- Question ) React에서 **조건부 렌더링된 컴포넌트가 다시 렌더링**될 때, 해당 컴포넌트의 useState 훅은 상태가 처음부터 다시 생성되는 걸까? 아니면 이전 상태를 인덱스 기반으로 유지할까?

  - GPT say ) 조건부 렌더링으로 인해 컴포넌트가 렌더링되지 않으면, **해당 컴포넌트의 훅은 사라지며 상태도 함께 제거**된다. **이후 다시 렌더링되면 훅은 처음부터 새로 생성**된다. 훅은 컴포넌트의 렌더링 시점에 호출 순서를 기준으로 관리되므로, 조건문 안에서는 사용할 수 없다.

- Question ) '컴포넌트마다 내부 훅 호출 순서에 의지한다' 라는 부분에서 '각 컴포넌트마다 state 배열이 만들어지는 것일까?' 라는 의문을 가짐

  - GPT say ) React에서는 각 컴포넌트 인스턴스마다 별도의 state 배열이 생성된다.

<br/>

---

<br/>

## [3️⃣ 렌더링 그리고 커밋](https://ko.react.dev/learn/render-and-commit)

> **학습 내용**
>
> - [React에서 렌더링의 의미](#-react에서-렌더링의-의미)
> - [React가 컴포넌트를 언제, 왜 렌더링 하는지](#-react가-컴포넌트를-언제-왜-렌더링-하는지)
> - [화면에 컴포넌트를 표시하는 단계](#-화면에-컴포넌트를-표시하는-단계)
> - [렌더링이 항상 DOM 업데이트를 하지 않는 이유](#-렌더링이-항상-dom-업데이트를-하지-않는-이유)

<br/>

### ✅ React에서 렌더링의 의미

“렌더링”은 React에서 컴포넌트를 호출하는 것이다.

<br/>

### ✅ React가 컴포넌트를 언제, 왜 렌더링 하는지

React는 컴포넌트의 초기 렌더링 시, 또는 state가 업데이트 될 경우 렌더링한다.

props의 변경으로 인한 렌더링 또한 누군가의 state가 바뀌었기 때문이다. 결국 모두 state가 바껴서 그렇다.

<br/>

### ✅ 화면에 컴포넌트를 표시하는 단계

**트리거 ⇒ 렌더링 ⇒ 커밋** 단게를 거친다.

트리거는 setState()과 같은 함수 호출하는 것이다.

렌더링은 함수 실행 (컴포넌트 함수 실행)을 의미하며,

커밋은 실제로 화면에 보여주는 동작을 의미한다.

<br/>

### ✅ 렌더링이 항상 DOM 업데이트를 하지 않는 이유

렌더링 했을 때 기존에 DOM이랑 동일하면 업데이트를 하지 않는다.

<br/>

**📎 토론 내용**

- 메타 : 어차피 React는 리렌더링 후 실제 DOM과 비교해 바뀐 부분만 업데이트하는데, 그렇다면 렌더링 최적화는 왜 필요한걸까?

  - Answer ) 렌더링 최적화는 "**화면에 반영되는 부분**"이 아닌, "**렌더링 함수 자체의 실행 횟수와 범위**"를 줄이기 위해 필요하다.
    화면에 변한 부분만 갱신되더라도, 그 이전 단계인 리렌더링 + 가상 DOM 비교가 무거우면 앱 전체 성능에 영향을 미치게 된다.

- 변경이 됐을 때 과거 VDOM이랑 최신 VDOM이랑 먼저 비교하게 된다. 그리고 최신 VDOM이랑 DOM이랑 한번 더 비교해서 달라진 부분을 화면에 보여준다.

<br/>

---

<br/>

## [4️⃣ 스냅샷으로서의 State] (https://ko.react.dev/learn/state-as-a-snapshot)

> **학습 내용**
>
> - [state 설정으로 리렌더링이 동작하는 방식](#-state-설정으로-리렌더링이-동작하는-방식)
> - [state 업데이트 시기 및 방법](#-state-업데이트-시기-및-방법)
> - [state를 설정한 직후에 state가 업데이트되지 않는 이유](#-state를-설정한-직후에-state가-업데이트되지-않는-이유)
> - [이벤트 핸들러가 state의 “스냅샷”에 접근하는 방법](#-이벤트-핸들러가-state의-스냅샷에-접근하는-방법)

<br/>

### ✅ state 설정으로 리렌더링이 동작하는 방식

setState를 사용해서 상태가 변경이 되면 리렌더링이 일어난다.

<br/>

### ✅ state 업데이트 시기 및 방법

setState를 통해서 상태를 변경할 수 있다.

<br/>

### ✅ state를 설정한 직후에 state가 업데이트되지 않는 이유

React의 상태는 컴포넌트마다 불변성을 유지하며, 변경 요청(setState)은 즉시 반영되지 않고 비동기적으로 처리된다.

성능 최적화를 위해 렌더링 사이클과 함께 업데이트되기 때문이다.

<br/>

### ✅ 이벤트 핸들러가 state의 “스냅샷”에 접근하는 방법

React의 state 자체가 "스냅샷"이므로, 이벤트 핸들러에서는 그 시점의 state를 그대로 참조한다.

<br/>

---

<br/>

## [5️⃣ State 업데이트 큐] (https://ko.react.dev/learn/queueing-a-series-of-state-updates)

> **학습 내용**
>
> - [”batching”이란 무엇이며 React가 여러 state 업데이트를 처리하는 방법](#-batching이란-무엇이며-react가-여러-state-업데이트를-처리하는-방법)
> - [동일한 state 변수에서 여러 업데이트를 연속으로 적용하는 방법](#-동일한-state-변수에서-여러-업데이트를-연속으로-적용하는-방법)

<br/>

### ✅ ”batching”이란 무엇이며 React가 여러 state 업데이트를 처리하는 방법

”batching”이란 한꺼번에 모아서 상태를 처리하는 것을 의미한다.

이벤트가 한번 일어날 때 마다 batching이 일어난다.

<br/>

### ✅ 동일한 state 변수에서 여러 업데이트를 연속으로 적용하는 방법

상태 업데이트 함수(setState)에 콜백 형태의 업데이트 함수를 전달해야 한다.

<br/>

**📎 토론 내용**

- 머핀 : 이벤트 핸들러 내부에서 setState 외에도 여러 함수를 함께 실행하면, 어떤 순서로 처리되는지? 그리고 setState는 어떤 큐에 들어가는 것이며, 다른 함수들도 그 큐에 들어가는 건가?
  - Answer ) setState 안에 전달된 업데이트 함수만 React 내부 큐에 들어가서 일괄 처리되며, 그 외의 일반 함수들은 이벤트 핸들러 실행 시점에 바로 동작한다. 따라서 하나의 이벤트 핸들러 내에서 여러 동작이 있어도, setState는 지연 처리되고 나머지 로직은 즉시 실행된다.

<br/>

---

<br/>

## [6️⃣ 객체 State 업데이트하기] (https://ko.react.dev/learn/updating-objects-in-state)

> **학습 내용**
>
> - [React state에서 객체를 올바르게 업데이트하는 방법](#-react-state에서-객체를-올바르게-업데이트하는-방법)
> - [중첩된 객체를 변경하지 않고 업데이트하는 방법](#-중첩된-객체를-변경하지-않고-업데이트하는-방법)
> - [불변성이란 무엇인지, 그리고 불변성을 지키는 방법](#-불변성이란-무엇인지-그리고-불변성을-지키는-방법)
> - [Immer로 반복을 줄여 객체를 복사하는 방법](#-immer로-반복을-줄여-객체를-복사하는-방법)

<br/>

### ✅ React state에서 객체를 올바르게 업데이트하는 방법

기존 객체를 직접 수정하지 말고, 복사본을 만들어 수정한 뒤 setState 해야한다.

이전값을 참조할 수 있어야 하기 때문이다.

<br/>

### ✅ 중첩된 객체를 변경하지 않고 업데이트하는 방법

스프레드 연산자 또는 immer 를 사용해서 업데이트 할 수 있다.

<br/>

### ✅ 불변성이란 무엇인지, 그리고 불변성을 지키는 방법

불변성이란 변하지 않는 값을 의미한다. “읽기 전용” 으로도 이해할 수 있다.

불변성을 지키기 위해서는 스프레드 연산자 또는 immer 를 사용하는 방법이 있다.

<br/>

### ✅ Immer로 반복을 줄여 객체를 복사하는 방법

```jsx
const [person, updatePerson] = useImmer({
  name: "Michel",
  age: 33,
});

function updateName(name) {
  updatePerson((draft) => {
    draft.name = name;
  });
}
```

**immer 추가 학습자료**

- 목적

  - `useImmer는` React의 useState와 동일한 방식으로 상태를 관리하지만, 복잡한 불변 객체를 더 직관적이고 안전하게 수정할 수 있도록 도와주는 커스텀 훅이다.

- 🔑 핵심 포인트 2가지

  - **freeze**: 초기 상태를 불변 객체로 고정해준다. useState로 초기 상태를 설정할 때 `freeze()` 함수를 사용해 깊은 불변 객체로 만들어준다.

    ```jsx
    freeze(initialValue, true);
    ```

  - **produce** : 상태를 마치 '변경하는 것처럼' 다룰 수 있게 해준다.`produce()`는 기존 상태 baseState를 Proxy 객체인 draft로 감싸서 넘겨줌.

  사용자가 draft에서 값을 수정하면, Proxy의 `set()` 핸들러가 작동하여 변경사항을 기록

  draft 수정이 끝나면, immer는 이를 바탕으로 새로운 객체(nextState) 를 만들어 리턴 → 원본 상태는 변경되지 않음

  ```jsx
  produce(baseState, (draft) => {
    draft.someField = "new value";
  });
  ```

  <br/>

---

<br/>

## [7️⃣ 배열 State 업데이트하기] (https://ko.react.dev/learn/updating-arrays-in-state)

> **학습 내용**
>
> - React state에서 배열의 항목을 추가, 삭제 또는 변경하는 방법
> - 배열 내부의 객체를 업데이트하는 방법
> - Immer로 덜 반복해서 배열을 복사하는 방법

<br/>

just immer + 스프레드 연산자 사용하기~

<br/>

---

## 회고

- 머핀

  - 대면으로 이야기하니까 훨씬 좋았다. 일람을 맞추니까 너무 딥하게 들어가려고 할 때 알림으로 통제가 되니까, 그나마 시간이 적게 드는 것 같아서 좋았다!!!!

- 메타

  - 뒤로갈수록 집중력이 흐려져서 힘들긴 했지만, 오늘도 유익하고 재밌었다. 왜 스터디를 하는지 알 거 같은 리액트 스터디였다.

- 캉골

  - 와 멀티 너무 힘들어요 근데 나름 정리하다보니 더 머리는 많이 쓰는 . 것같긴함. 그래서 결론이 뭐야 ~ 남발한듯

- 해삐

  - 여러 토론을 나눌 수 있어서 유익했다.함께 나누니까 훨씬 더 많은 정보를 얻어가는 것 같다.

- 헤일리

  - 골캉아 기록하느라 고생했다. 오늘도 많은 것을 얻어가고, 모르는 부분에 대해 뇌 싱크를 맞출 수 있어서 좋았다. 한 명이 모르면 함께 모르는 것이니 레벨 2 끝나기 전에 궁금증을 다 해결해보자~

- 퐁주

  - 리액트가 어떻게 state를 보고 있는지, state를 관리할 수 있는지 알 수 있는 기회였다. 이전에 바닐라 js에서 언급됐던 키워드들이 연관된 것도 신기했다. 역시 집단지성으로하면 얻는 것이 많다.

- 상추

  - 뭔가 저는 공식문서 읽어올때 그냥 '음 그렇군' 납득하면서 읽었는데, 다들 왜 그렇게 되는지 궁금해하고 그걸 이야깃거리로 가져온게 신기했다. 뭔가 머리가 말랑말랑해지는 것 같고.. 맥락이 연결되고. 나도 다음엔 그렇게 읽어봐야겠따. . 따로 생각안해봐서 그런지 추론하기 힘들었다 흑흑
