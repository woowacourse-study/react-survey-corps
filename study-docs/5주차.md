# 2주차 스터디 기록

- 일시 : 2025.05.29
- 참여 인원 : 퐁쥬, 머핀, 헤일리, 캉골, 상추, 메타, 해삐
- 주제 : **탈출구**

## 목차

<details>
  <summary>목차 바로가기</summary>

- [2주차 스터디 기록](#2주차-스터디-기록)
  - [목차](#목차)
  - [1️⃣ React Effect의 생명주기](#1️⃣-react-effect의-생명주기)
    - [✅ effect의 생명주기가 컴포넌트의 생명주기와 다른 점](#-effect의-생명주기가-컴포넌트의-생명주기와-다른-점)
    - [✅ 각 effect를 개별적으로 생각하는 방법](#-각-effect를-개별적으로-생각하는-방법)
    - [✅ effect를 다시 동기화해야 하는 시기와 그 이유](#-effect를-다시-동기화해야-하는-시기와-그-이유)
    - [✅ effect의 의존성이 결정되는 방법](#-effect의-의존성이-결정되는-방법)
    - [✅ 값이 유동적이라는 것의 의미](#-값이-유동적이라는-것의-의미)
    - [✅ 빈 의존성 배열이 의미하는 것](#-빈-의존성-배열이-의미하는-것)
    - [✅ React가 린터로 의존성이 올바른지 확인하는 방법](#-react가-린터로-의존성이-올바른지-확인하는-방법)
    - [✅ 린터에 동의하지 않을 때 해야 할 일](#-린터에-동의하지-않을-때-해야-할-일)
  - [2️⃣ Effect에서 이벤트 분리하기](#2️⃣-effect에서-이벤트-분리하기)
    - [✅ 이벤트 핸들러와 Effect 중에 선택하는 방법](#-이벤트-핸들러와-effect-중에-선택하는-방법)
    - [✅ Effect는 반응형이고 이벤트 핸들러는 아닌 이유](#-effect는-반응형이고-이벤트-핸들러는-아닌-이유)
    - [✅ Effect의 코드 일부가 반응형이 아니길 원한다면 해야 할 것](#-effect의-코드-일부가-반응형이-아니길-원한다면-해야-할-것)
    - [✅ Effect 이벤트의 정의와 Effect에서 추출하는 방법](#-effect-이벤트의-정의와-effect에서-추출하는-방법)
    - [✅ Effect 이벤트를 사용해 Effect에서 최근의 props와 state를 읽는 방법](#-effect-이벤트를-사용해-effect에서-최근의-props와-state를-읽는-방법)
  - [3️⃣ Effect의 의존성 제거하기](#3️⃣-effect의-의존성-제거하기)
    - [✅ Effect 의존성 무한 루프를 수정하는 방법](#-effect-의존성-무한-루프를-수정하는-방법)
    - [✅ 의존성을 제거하고자 할 때 해야 할 일](#-의존성을-제거하고자-할-때-해야-할-일)
    - [✅ Effect에 “반응”하지 않고 Effect에서 값을 읽는 방법](#-effect에-반응하지-않고-effect에서-값을-읽는-방법)
    - [✅ 객체와 함수 의존성을 피하는 방법과 이유](#-객체와-함수-의존성을-피하는-방법과-이유)
    - [✅ 의존성 린터를 억제하는 것이 위험한 이유와 대신 할 수 있는 일](#-의존성-린터를-억제하는-것이-위험한-이유와-대신-할-수-있는-일)
  - [4️⃣ 커스텀 Hook으로 로직 재사용하기](#4️⃣-커스텀-hook으로-로직-재사용하기)
    - [✅ 커스텀 Hook이 무엇이고, 어떻게 본인만의 Hook을 작성하는 지](#-커스텀-hook이-무엇이고-어떻게-본인만의-hook을-작성하는-지)
    - [✅ 컴포넌트 간 로직을 재사용하는 방법](#-컴포넌트-간-로직을-재사용하는-방법)
    - [✅ 나만의 커스텀 Hook 이름 짓기와 구조 잡기](#-나만의-커스텀-hook-이름-짓기와-구조-잡기)
    - [✅ 언제 그리고 왜 커스텀 Hook을 추출해야 하는지](#-언제-그리고-왜-커스텀-hook을-추출해야-하는지)

</details>

---

<br/>

## [1️⃣ React Effect의 생명주기](https://ko.react.dev/learn/lifecycle-of-reactive-effects)

> **학습 내용**
>
> - effect의 생명주기가 컴포넌트의 생명주기와 다른 점
> - 각 effect를 개별적으로 생각하는 방법
> - effect를 다시 동기화해야 하는 시기와 그 이유
> - effect의 의존성이 결정되는 방법
> - 값이 유동적이라는 것의 의미
> - 빈 의존성 배열이 의미하는 것
> - React가 린터로 의존성이 올바른지 확인하는 방법
> - 린터에 동의하지 않을 때 해야 할 일

<br/>

### ✅ effect의 생명주기가 컴포넌트의 생명주기와 다른 점

컴포넌트와 effct는 서로 다른 생명주기를 가진다. effect는 컴포넌트의 렌더링이 끝난 다음 실행이 된다.

리렌더링이 되어도 effect는 발생 안할수도 있다.

<br/>

### ✅ 각 effect를 개별적으로 생각하는 방법

단일 책임 원칙에 따라 각 effect를 분리하여 생각해야한다.

서로 불필요한 렌더링이 일어날 수 있으니 의존성을 떨어뜨려야 한다.

<br/>

### ✅ effect를 다시 동기화해야 하는 시기와 그 이유

의존성 배열에 포함된 값이 변경될 때 effect를 다시 동기화해야 한다.

이는 변경된 값에 따라 부수 효과(side effect)를 다시 실행하기 위함이다.

린트에서 경고뜨는 것을 없애지 마라.

- 퐁쥬 : 근데 나는 린트 무시하고 그냥 냅뒀다!
- 머핀 : 근데 린트 에러를 무시하지 않고 다 넣으면 엄청 민감하게 반응하게 되는데, 이건 어떻게 해결해야 할까? (뒤에 다른 부분으로 설명해준다.)

<br/>

### ✅ effect의 의존성이 결정되는 방법

effect 내에서 사용되는 모든 반응형 값(props, state 등)에 의해 의존성이 결정된다.

<br/>

### ✅ 값이 유동적이라는 것의 의미

렌더링마다 값이 변경되거나 바뀔 수 있음을 의미한다. (reactive 하다의 의미)

즉, 렌더링마다 값이 바뀔 수 있으니까 UseEffect 안에 코드를 작성하는 것.

컴포넌트 내부에 있는 모든 값은 반응형이다. 어떤 값이든 useEffect 의존성 배열에 들어갈 수 있다는 의미이다.

<br/>

### ✅ 빈 의존성 배열이 의미하는 것

마운트 시 딱 한 번만 실행되거나, 언마운트 될 때 실행되는 것을 의미한다.

유조 : setTimeOut을 쓴다면 에러를 방지하기 위해 무조건 clearTimeout을 사용해야 한다.

cleanup 함수를 넣어주지 않는다면 순서때문에 엉킬 수 있다. 그래서 메모리 낭비 하지 않으려면 cleanup 함수를 작성해줘야 한다.

<br/>

### ✅ React가 린터로 의존성이 올바른지 확인하는 방법

린터가 자동으로 의존성 배열에 포함되어야 할 값들을 확인해주지만, (개발자 스스로가) 반응형 값이 무엇인지 알고 있는게 좋다.

**외부에서 선언되었는데 변경될 수 있는 값이면 의존성 배열에 넣어야 한다.**

의존성 배열이 비어있다는건 useEffect안에서 어떠한 반응형 값을 사용하지 않음을 의미한다.

<br/>

### ✅ 린터에 동의하지 않을 때 해야 할 일

린터의 제안이 항상 옳지는 않으므로, 경우에 따라 린트 규칙을 무시해야 할 수도 있다.

<br/>

---

<br/>

## [2️⃣ Effect에서 이벤트 분리하기](https://ko.react.dev/learn/separating-events-from-effects)

> **학습 내용**
>
> - 이벤트 핸들러와 Effect 중에 선택하는 방법
> - Effect는 반응형이고 이벤트 핸들러는 아닌 이유
> - Effect의 코드 일부가 반응형이 아니길 원한다면 해야 할 것
> - Effect 이벤트의 정의와 Effect에서 추출하는 방법
> - Effect 이벤트를 사용해 Effect에서 최근의 props와 state를 읽는 방법

<br/>

### ✅ 이벤트 핸들러와 Effect 중에 선택하는 방법

사용자 액션(예: onClick 등)에 직접 반응해야 할 때는 이벤트 핸들러를 사용하고, 상태 변화에 따라 부수 효과가 필요할 때는 effect를 사용해야 한다.

connect, disconnect을 요청하는 로직은 어디에 있어야 할까?

버튼을 누를 때마다 이벤트가 실행되기 때문에, 존재하지 않더라도 계속 요청이 간다. 따라서 이벤트 핸들러에 해당 로직이 존재해선 안된다.

useEffect에 로직을 넣는다면 마운트 될 때 한번만 실행되므로, 불필요한 반복 요청을 막을 수 있다.

<br/>

### ✅ Effect는 반응형이고 이벤트 핸들러는 아닌 이유

effect는 의존성 배열에 있는 값이 바뀔 때마다 자동으로 실행되어 반응형이다.

반면, 이벤트 핸들러는 사용자의 직접적인 액션이 있을 때만 실행되므로 반응형이 아니다.

<br/>

### ✅ Effect의 코드 일부가 반응형이 아니길 원한다면 해야 할 것

해당 함수를 의존성 배열에 넣지 않거나, useCallback/useMemo 등으로 참조값을 고정해야 한다.

<br/>

### ✅ Effect 이벤트의 정의와 Effect에서 추출하는 방법

effect 이벤트란 effect 내부에서 정의한 함수(예: 이펙트 이벤트 훅)를 의미한다.

필요에 따라 effect 안에서 이벤트 정의 및 추출이 가능하다.

but 아직 개발중 이슈 ..

<br/>

### ✅ Effect 이벤트를 사용해 Effect에서 최근의 props와 state를 읽는 방법

부모에서 자식으로 매개변수를 통해서 넘겨줄 수 있다.

<br/>

---

<br/>

## [3️⃣ Effect의 의존성 제거하기](https://ko.react.dev/learn/removing-effect-dependencies)

> **학습 내용**
>
> - Effect 의존성 무한 루프를 수정하는 방법
> - 의존성을 제거하고자 할 때 해야 할 일
> - Effect에 “반응”하지 않고 Effect에서 값을 읽는 방법
> - 객체와 함수 의존성을 피하는 방법과 이유
> - 의존성 린터를 억제하는 것이 위험한 이유와 대신 할 수 있는 일

<br/>

### ✅ Effect 의존성 무한 루프를 수정하는 방법

의존성 배열에 함수나 객체 등 참조값이 자주 바뀌는 값을 넣으면 무한 루프가 발생할 수 있다.

이를 방지하려면 useMemo, useCallback 등으로 참조값을 고정하거나, 불필요한 의존성을 제거하면 된다.

<br/>

### ✅ 의존성을 제거하고자 할 때 해야 할 일

코드를 변경하면 된다!

effect 내부에서 실제로 사용하는 값만 의존성 배열에 넣는 것이 원칙이다.

불필요한 의존성은 제거하고, 꼭 필요한 값만 넣어야 하며, 외부 선언 함수나 불변 객체는 의존성 배열에 넣지 않아도 된다.

<br/>

### ✅ Effect에 “반응”하지 않고 Effect에서 값을 읽는 방법

Effect 이벤트를 사용하면 된다. 하지만 아직 개발중 이슈 ..

<br/>

### ✅ 객체와 함수 의존성을 피하는 방법과 이유

객체나 함수는 참조값이 바뀔 때마다 effect가 재실행된다.

이를 피하려면 컴포넌트 외부로 빼거나 불필요한 재실행을 막기 위해서 useMemo, useCallback으로 감싸서 참조값을 고정하면 된다.

1. **안바뀌는 값이면 컴포넌트 밖을 빼라**
2. **바뀌는 값이면 useEffect 안에서 사용해라.**

<br/>

### ✅ 의존성 린터를 억제하는 것이 위험한 이유와 대신 할 수 있는 일

린터의 경고를 무시하면 최신 값이 반영되지 않거나, 예기치 않은 버그가 발생할 수 있다.

대신, 실제로 effect 내부에서 사용하는 값만 의존성 배열에 넣고, 참조형 데이터는 useMemo/useCallback 등으로 안정성을 확보하는 것이 좋다.

<br/>

---

<br/>

## [4️⃣ 커스텀 Hook으로 로직 재사용하기](https://ko.react.dev/learn/reusing-logic-with-custom-hooks)

> **학습 내용**
>
> - 커스텀 Hook이 무엇이고, 어떻게 본인만의 Hook을 작성하는 지
> - 컴포넌트 간 로직을 재사용하는 방법
> - 나만의 커스텀 Hook 이름 짓기와 구조 잡기
> - 언제 그리고 왜 커스텀 Hook을 추출해야 하는지

<br/>

### ✅ 커스텀 Hook이 무엇이고, 어떻게 본인만의 Hook을 작성하는 지

리액트 훅을 함수로 한번 더 감싸서 사용하는 것이다.

`use~` prefix 로 시작해야 한다는 규칙이 있다.

<br/>

### ✅ 컴포넌트 간 로직을 재사용하는 방법

사실 재사용성은 별로 중요하지 않았다. 결국 부가적인 부분이고, 로직을 분리할 때 사용이 많이 되더라.

<br/>

### ✅ 나만의 커스텀 Hook 이름 짓기와 구조 잡기

`use~` prefix 로 시작해야 한다

<br/>

### ✅ 언제 그리고 왜 커스텀 Hook을 추출해야 하는지

중복된 로직이 존재하거나, 관심사를 분리하고 싶을 때 사용할 수 있다.
